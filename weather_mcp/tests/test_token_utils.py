import pytest
import re
import math

# Add project root to sys.path to allow importing weather_mcp.token_utils
# This assumes tests are run from the directory containing weather_mcp or project root
import os
import sys
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
sys.path.insert(0, PROJECT_ROOT)

from weather_mcp.token_utils import generate_bearer_token

# Regex for URL-safe characters (alphanumeric, hyphen, underscore)
URL_SAFE_CHAR_REGEX = re.compile(r"^[A-Za-z0-9_-]+$")

def calculate_expected_token_length(byte_length: int) -> int:
    """
    Calculates the expected string length of a token generated by secrets.token_urlsafe(byte_length).
    The formula is ceil(n * 4 / 3), where n is the byte_length.
    """
    return math.ceil(byte_length * 4 / 3)

def test_generate_bearer_token_default_length():
    """
    Tests generate_bearer_token with default length.
    Default byte length is 32.
    """
    token = generate_bearer_token()
    expected_length = calculate_expected_token_length(32) # Default byte length is 32

    assert isinstance(token, str)
    assert len(token) == expected_length, \
        f"Token length should be {expected_length} for default byte length 32, but got {len(token)}"
    assert URL_SAFE_CHAR_REGEX.match(token), \
        f"Token '{token}' contains non-URL-safe characters."

def test_generate_bearer_token_custom_length():
    """
    Tests generate_bearer_token with a custom length.
    Using byte length 48.
    """
    custom_byte_length = 48
    token = generate_bearer_token(length=custom_byte_length)
    expected_length = calculate_expected_token_length(custom_byte_length)

    assert isinstance(token, str)
    assert len(token) == expected_length, \
        f"Token length should be {expected_length} for byte length {custom_byte_length}, but got {len(token)}"
    assert URL_SAFE_CHAR_REGEX.match(token), \
        f"Token '{token}' contains non-URL-safe characters."

def test_generate_bearer_token_another_custom_length():
    """
    Tests generate_bearer_token with another custom length to ensure calculation is robust.
    Using byte length 16.
    """
    custom_byte_length = 16
    token = generate_bearer_token(length=custom_byte_length)
    expected_length = calculate_expected_token_length(custom_byte_length) # For 16 bytes, should be 22 chars. (ceil(16*4/3) = ceil(21.33) = 22)

    assert isinstance(token, str)
    assert len(token) == expected_length, \
        f"Token length should be {expected_length} for byte length {custom_byte_length}, but got {len(token)}"
    assert URL_SAFE_CHAR_REGEX.match(token), \
        f"Token '{token}' contains non-URL-safe characters."


def test_generate_bearer_token_uniqueness():
    """
    Tests that subsequent calls to generate_bearer_token produce unique tokens.
    """
    token1 = generate_bearer_token()
    token2 = generate_bearer_token()

    assert token1 != token2, "Generated tokens should be unique."

def test_generate_bearer_token_zero_length_input():
    """
    Tests generate_bearer_token with zero length input.
    secrets.token_urlsafe(0) produces an empty string.
    """
    custom_byte_length = 0
    token = generate_bearer_token(length=custom_byte_length)
    expected_length = calculate_expected_token_length(custom_byte_length) # ceil(0*4/3) = 0

    assert isinstance(token, str)
    assert len(token) == expected_length, \
        f"Token length should be {expected_length} for byte length {custom_byte_length}, but got {len(token)}"
    # An empty string will match the regex, which is fine. Or use specific check:
    assert token == ""

def test_generate_bearer_token_negative_length_input():
    """
    Tests generate_bearer_token with negative length input.
    secrets.token_urlsafe() typically defaults for n < 0, or could error depending on Python version.
    The type hint says int, but secrets.token_urlsafe behavior with negative n can be version specific.
    Let's assume it might raise an error or behave like default.
    The current implementation of token_urlsafe (e.g. Python 3.9+) uses `max(0, n)` effectively for some internal steps
    or takes n as specific number of bytes. For negative, it might default to a standard byte count if not erroring.
    Let's test if it raises TypeError or ValueError as good practice for such inputs.
    For `secrets.token_urlsafe(-10)`, it actually uses `n` as is, and `random.getrandbits(n*8)` would fail.
    It will raise a ValueError from `random.getrandbits`.
    """
    with pytest.raises((ValueError, TypeError)): # Catches if it's a ValueError or TypeError
        generate_bearer_token(length=-10)

# To run these tests:
# Ensure `weather_mcp` directory is in PYTHONPATH or run from parent of `weather_mcp`
# Example: `python -m pytest weather_mcp/tests/test_token_utils.py`
# The `PROJECT_ROOT` and `sys.path.insert` are attempts to make test discovery and imports robust.
# (Same logic as in test_auth.py for path handling)
